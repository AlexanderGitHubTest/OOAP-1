1. АТД LinkedList

==============================================================================================
================================= Начало АТД LinkedList ======================================

// АТД LinkedList
abstract class LinkedList<T>

    public const int HEAD_OK = 1; // последняя head() отработала нормально
    public const int HEAD_ERR = 2; // список пуст

    public const int TAIL_OK = 1; // последняя tail() отработала нормально
    public const int TAIL_ERR = 2; // список пуст

    public const int RIGHT_OK = 1; // последняя right() отработала нормально
    public const int RIGHT_ERR_EMPTY = 2; // список пуст
    public const int RIGHT_ERR_LAST = 3; // курсор стоит на последнем элементе

    public const int GET_OK = 1; // последняя get() отработала нормально
    public const int GET_ERR = 2; // список пуст

    public const int PUT_RIGHT_OK = 1; // последняя put_right() отработала нормально
    public const int PUT_RIGHT_ERR = 2; // список пуст

    public const int PUT_LEFT_OK = 1; // последняя put_left() отработала нормально
    public const int PUT_LEFT_ERR = 2; // список пуст

    public const int REMOVE_OK = 1; // последняя remove() отработала нормально
    public const int REMOVE_ERR = 2; // список пуст

    public const int ADD_TO_EMPTY_OK = 1; // последняя add_to_empty() отработала нормально
    public const int ADD_TO_EMPTY_ERR = 2; // список не пуст

    public const int REPLACE_OK = 1; // последняя replace() отработала нормально
    public const int REPLACE_ERR = 2; // список пуст

    public const int FIND_OK = 1; // последняя find() отработала нормально
    public const int FIND_ERR_EMPTY = 2; // список пуст
    public const int FIND_ERR_TAIL = 3; // текущий узел является последним в списке
    public const int FIND_ERR_NOT_FOUND = 3; // не найдено искомое значение в узлах правее текущего

    public const int IS_HEAD_OK = 1; // последняя is_head() отработала нормально
    public const int IS_HEAD_ERR = 2; // список пуст

    public const int IS_TAIL_OK = 1; // последняя is_tail() отработала нормально
    public const int IS_TAIL_ERR = 2; // список пуст

    // конструктор
    public LinkedList<T> LinkedList(); // постусловие: создан новый пустой список


    // команды

// установить курсор на первый узел в списке
// предусловие: список не пуст
// постусловие: курсор стоит на 1-м узле списка
    public void head();

// установить курсор на последний узел в списке
// предусловие: список не пуст
// постусловие: курсор стоит на последнем узле списка
    public void tail();

// сдвинуть курсор на один узел вправо
// предусловие: список не пуст
// предусловие: курсор стоит не на последнем узле списка
// постусловие: курсор переместился на один узел вправо
    public void right();

// вставить следом за текущим узлом
// новый узел с заданным значением
// предусловие: список не пуст
// постусловие: справа от курсора добавлен узел с заданным значением
    public void put_right(T value);

// вставить перед текущим узлом
// новый узел с заданным значением
// предусловие: список не пуст
// постусловие: слева от курсора добавлен узел с заданным значением
    public void put_left(T value);

// удалить текущий узел
// (курсор смещается к правому соседу, если он есть,
// в противном случае курсор смещается к левому соседу,
// если он есть)
// предусловие: список не пуст
// постусловие: узел, на который указывал курсор, удален
// постусловие: если был узел справа от текущего, то курсор переместился на него
// постусловие: если не было узла справа от текущего, но был узел слева от текущего, 
//              то курсор переместился на него
    public void remove();

// очистить список
// постусловие: пустой список
    public void clear()

// добавить новый узел в пустой список
// предусловие: пустой список
// постусловие: список с одним узлом
// постусловие: курсор указывает на единственный узел списка
    public void add_to_empty(T value)

// добавить новый узел в хвост списка
// новый узел с заданным значением
// добавление: считаем, что для пустого списка будет просто добавление первого узла
// постусловие: если список пустой, то добавлен первый узел
//              если список не пустой, то добавлен узел в конец
    public void add_tail(T value);

// заменить значение текущего узла на заданное
// предусловие: список не пуст
// постусловие: значение узла, куда указывает курсор, изменено на заданное
    public void replace(T value);

// установить курсор на следующий узел
// с искомым значением (по отношению к текущему узлу)
// предусловие: список не пуст
// предусловие: текущий узел не хвост списка
// предусловие: правее текущего узла есть хотя бы один узел с заданным значением
// постусловие: курсор переставлен на ближайший узел справа с заданным значением
    public void find(T value);

// удалить в списке все узлы с заданным значением
// добавление: считаем, что отсутствие узлов с заданным значением это нормально
    public void remove_all(T value);


    // запросы:
// получить значение текущего узла
// предусловие: стек не пустой
    public T get();

// посчитать количество узлов в списке
    public int size();

// находится ли курсор в начале списка?
// предусловие: стек не пустой
    public bool is_head();

// находится ли курсор в конце списка?
// предусловие: стек не пустой
    public bool is_tail();

// установлен ли курсор на какой-либо узел в списке
// (по сути, непустой ли список)
    public bool is_value();


    // дополнительные запросы:
    public int get_head_status(); // возвращает значение HEAD_*
    public int get_tail_status(); // возвращает значение TAIL_*
    public int get_right_status(); // возвращает значение RIGHT_*
    public int get_get_status(); // возвращает значение GET_*
    public int get_put_right_status(); // возвращает значение PUT_RIGHT_*
    public int get_put_left_status(); // возвращает значение PUT_LEFT_*
    public int get_remove_status(); // возвращает значение PUT_REMOVE_*
    public int get_add_to_empty_status(); // возвращает значение ADD_TO_EMPTY_*
    public int get_replace_status(); // возвращает значение REPLACE_*
    public int get_find_status(); // возвращает значение FIND_*
    public int get_is_head_status(); // возвращает значение IS_HEAD_*
    public int get_is_tail_status(); // возвращает значение IS_TAIL_*

================================ Завершение АТД LinkedList ===================================
==============================================================================================

2. "Почему операция tail не сводима к другим операциям (если исходить из эффективной реализации)"
Если tail реализовывать через остальные атомарные команды, то вставка будет за время O(N), так как придётся
перебирать узлы (двигаться к концу списка командой right), а вне типа мы ничего хранить не должны. 
Быстро добраться к хвосту важно для скорости операций добавления в хвост. При введении команды tail появляется 
возможность организовать быстрое перемещение к хвосту (например, при реализации создать внутреннюю переменную со ссылкой на хвост).

3. "Операция поиска всех узлов с заданным значением, выдающая список таких узлов, уже не нужна. Почему?"
Используя find, возможно сделать итератор и обойти все такие узлы. Для удаления узлов с заданным значением есть отдельная команда, а
заменить значения можно в процессе перебора.
